---
title: "ESM 204 Homework 3"
author: "Kiera Matiska, Virginia Pan, Devon Rossi"
date: "5/6/2022"
output:
   html_document: 
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
#library(rootSolve)
library(janitor)
library(tibble)
library(equatiomatic)
```

```{r}
df <- read_csv("HW3_data.csv") %>% 
  select(-1) %>% 
  clean_names()

```

```{r}
# creates a function for the supply curve
mpc_curve <- function(q) {
  p <- mpc_slope * q
  p <- ifelse(p < 0, 0, p)
  return(p) }

# define a function to get demand
demand_quant <- function(p, model){
  q <- (p - model$coefficients[[1]])/model$coefficients[[2]]
  q <- ifelse(q<0,0,q)
  return(q) }

# for each p level, return estimated aggregate demand
demand_agg <- function(p){
  q <- demand_quant(p, model_demand_l) + demand_quant(p, model_demand_h)
  return(q)
}

demand_low <- function(p) {
  q <- demand_quant(p, model_demand_l)
  return(q)
}

demand_high <- function(p) {
  q <- demand_quant(p, model_demand_h)
  return(q) }
```

# Question 1

```{r}
# 2205 pounds = 1 ton
# $1 = 100 cents
MEC <- (100 * 0.85 * 51) / 2205
```

# Question 2

```{r}
model_demand_l <- lm(price_cents  ~ q_low_kwh, data=df)
model_demand_h <- lm(price_cents ~ q_high_kwh, data=df)
```

```{r}
# need to rearrange the parameter to get Q(P)! 

# Qgg = Qlow(P) + Qlow(h) 

# Importantly, since they-intercepts are different, we know that Qagg(P) will have a kink. I include an ifelse() statement to take
# care of the kink.

```


```{r}
price = seq(0, 30, length.out = 100)
Qagg <- map(price, demand_agg) %>% 
  unlist()
Qlow <- map(price, demand_low) %>% 
  unlist()
Qhigh <- map(price, demand_high) %>% 
  unlist()

df_agg <- tibble(Qagg = Qagg, price = price, mec = MEC)
df_high <- tibble(Q_high = Qhigh, price = price, mec = MEC)
df_low <- tibble(Q_low = Qlow, price = price, mec = MEC)

# Demand Aggregate equation: P = -3.68e-5Q + 29.78
D_agg <- lm(price ~ Qagg, data = df_agg)
p <- 10


# Calculate quantity at free-market equilibrium
d_agg_model <- demand_quant(p, D_agg)
```

```{r}
# find supply (MPC) curve equation
mpc_slope <- 10 / d_agg_model
# MPC equation: P = 1.86e-5Q


quantity = seq(0, 825000, length.out = 100)
mpc <- map(quantity, mpc_curve) %>% 
  unlist()

df_mpc <- tibble(quantity = quantity, price = mpc, mec = MEC, msc = (mpc_slope * quantity) + mec)

mpc_model <- lm(price ~ quantity, data = df_mpc)

```

#Define SCC conversion function

```{r}
SCC_conversion <- function(SCC_dollars)
{
  #given SCC in $, calc and return SCC in cents/kwH
  SCC <- (100*0.85*SCC_dollars)/2205
  return(SCC)
}
```

# Define Demand Functions

```{r}
  
# function for d_agg equation after kink (to find price)
D_agg_fun <- function(q) {
  p <- (D_agg$coefficients[[2]] * q) + D_agg$coefficients[[1]]
  return(p)
}

```

```{r}
MSC_eq <- function(MEC){
  MSC <- mpc_model
  MSC$coefficients[1] <- MSC$coefficients[1] + MEC
  return(MSC)
}
```

```{r}
# Linear model Intercept function
lmIntx <- function(fit1, fit2) {
  b1<- fit1$coefficient[1]  #y-int for fit1
  m1<- fit1$coefficient[2]  #slope for fit1
  b2<- fit2$coefficient[1]  #y-int for fit2
  m2<- fit2$coefficient[2]  #slope for fit2
  if(m1==m2 & b1==b2) {print("Lines are identical")
  } else if(m1==m2 & b1 != b2) {print("Lines are parallel")
  } else {
    x <- (b2-b1)/(m1-m2)      #solved general equation for x
    y <- m1*x + b1            #plug in the result
    ordered_pair <- c(x,y)
    return(ordered_pair)
  }
}

true_demand_curve <- function(p)
{
  if(p > model_demand_l$coefficients[1])
  {
    q <-demand_quant(p, model_demand_h)
  }
  if(p <= model_demand_l$coefficients[1])
  {
    q <- demand_quant(p, D_agg)
  }
  return(q)
}
  
```

```{r}
demand_agg_full_eq <- function(SCC)
{
  MSC <- MSC_eq(SCC)
  intersect_high <- lmIntx(MSC,model_demand_h)
  intersect_agg <- lmIntx(MSC, D_agg)
  #check which intersection is correct
  q_option1 <- true_demand_curve(intersect_high[2])
  q_option2 <- true_demand_curve((intersect_agg[2]))
  if(signif(q_option1,3) == signif(intersect_high[1],3))
  {
    eq_p_q <- intersect_high
  }
  else if(signif(q_option2,3) == signif(intersect_agg[1],3))
  {
    eq_p_q <- intersect_agg
  }
  return(eq_p_q)
}
```

```{r}
demand_agg_full_eq(MEC)
```

#Define Supply Functions 

```{r}
# creates a function for the supply curve
mpc_curve <- function(q) {
  p <- mpc_slope * q
  p <- ifelse(p < 0, 0, p)
  return(p) }
  
supply_quant <- function(p, model) {
  q <- (p - model$coefficients[[1]]) / model$coefficients[[2]]
  q <- ifelse(q < 0, 0, q)
  return(q) }
  
# find MSC function for price
MSC_fun <- function(q) {
  p <- mpc_slope * q + MEC
  return(p)
}


```

# Define consumer and producer surplus functions

```{r}
# I also define functions for calculating the consumer surplus:
CS <- function(p, model){
  q <- demand_quant(p, model)
  cs <- 0.5*(model$coefficients[[1]] - p)*q
  return(cs)
}

CS_agg <- function(p){
  cs <- CS(p,model_demand_l) + CS(p,model_demand_h)
  return(cs)
}

CS_high <- function(p){
  cs <- CS(p, model_demand_h)
  return(cs)
}

CS_low <- function(p){
  cs <- CS(p, model_demand_l)
  return(cs)
}

PS <- function(p, model) {
  q <- supply_quant(p, model)
  ps <- 0.5 * (p - model$coefficient[[1]]) * q
  return(ps)
}

# ps <- function(p) {
#   ps <- PS(p, mpc_model)
#   return(ps)

```

#Define tax functions 

```{r}
tax_rev <- function(q, MEC) {
  area <- MEC * q
  return(area)
}
```

```{r}
tax_rebate <- function(q, MEC, demand_ratio) {
  tax_reb <- demand_ratio * MEC * q
  return(tax_reb)
}
```

```{r}
welfare_h <- function(SCC) {
  eq_p_q <- demand_agg_full_eq(SCC)
  welfare_h <- CS(eq_p_q[2])
}
```

```{r}
env_damage_fun <- function(q, SCC) {
  env_damage <- q * SCC 
}

welfare_l <- function(SCC)
{
  eq_p_q <- demand_agg_full_eq(SCC)
  welfare_l<-CS(eq_p_q[2]) + tax_rebate(low_ratio, SCC, eq_p_q[1]) - env_damage_fun(eq_p_q, SCC)
}

producer_welfare <- function(SCC) {
  MSC <- MSC_fun(SCC) 
  eq_p_q <- demand_agg_full_eq(SCC)
  p_tau <- eq_p_q[2] - SCC
  producer_wel <- PS(p_tau, MSC)
  return(producer_wel)
}
```






































































# Questions {.tabset .tabset-fade}

## Question 1

```{r}
# 2205 pounds = 1 ton
# $1 = 100 cents
MEC <- (100 * 0.85 * 51) / 2205
```

The marginal external cost value is `r MEC` cents.

## Question 2

```{r}
model_demand_l <- lm(price_cents  ~ q_low_kwh, data=df)
model_demand_h <- lm(price_cents ~ q_high_kwh, data=df)

price = seq(0, 30, length.out = 100)
Qagg <- map(price, demand_agg) %>% 
  unlist()
Qlow <- map(price, demand_low) %>% 
  unlist()
Qhigh <- map(price, demand_high) %>% 
  unlist()

df_agg <- tibble(Qagg = Qagg, price = price, mec = MEC)
df_high <- tibble(Q_high = Qhigh, price = price, mec = MEC)
df_low <- tibble(Q_low = Qlow, price = price, mec = MEC)

# Demand Aggregate equation: P = -3.68e-5Q + 29.78
D_agg <- lm(price ~ Qagg, data = df_agg)
p <- 10

# Calculate quantity at free-market equilibrium
d_agg_model <- demand_quant(p, D_agg)
```

**Aggregate Demand Equation:** P = `r D_agg$coefficients`Q + `r D_agg$coefficients[2]`

**Free-Market Equilibrium:** (`r d_agg_model`, `r p`)

```{r}
# find supply (MPC) curve equation
mpc_slope <- 10 / d_agg_model
# MPC equation: P = 1.86e-5Q

quantity = seq(0, 825000, length.out = 100)
mpc <- map(quantity, mpc_curve) %>% 
  unlist()

df_mpc <- tibble(quantity = quantity, price = mpc, mec = MEC, msc = (mpc_slope * quantity) + mec)

mpc_model <- lm(price ~ quantity, data = df_mpc)
```

**Supply Curve Equation:** P = `r mpc_slope`Q

```{r}
# consumer surplus = 5,298,722.41 cents
consumer_surplus <- CS_agg(p)

# producer surplus = 2,690,612.46 cents
producer_surplus <- PS(p, mpc_model)

# TEC = 1,057,941.50 cents
TEC <- MEC * d_agg_model
```

**Consumer Surplus:** `r consumer_surplus` cents

**Producer Surplus:** `r producer_surplus` cents

**Total Environmental Cost:** `r TEC` cents

```{r}
ggplot() +
  geom_line(data = df_agg,
            aes(x = Qagg, y = price),
            color = "black") +
  geom_line(data = df_mpc,
            aes(x = quantity, y = price),
            color = "red") +
  geom_hline(yintercept = MEC,
             color = "darkgreen") +
  geom_line(data = df_mpc,
            aes(x = quantity, y = msc),
            color = "blue") +
  geom_line(data = df_high,
            aes(x = Q_high, y = price),
            color = "coral") +
  geom_line(data = df_low,
            aes(x = Q_low, y = price),
            color = "maroon")
```

## Question 3

```{r}
CS_high_val <- CS(p, model_demand_h)
CS_low_val <- CS(p, model_demand_l)

# 84.69% of the consumer surplus benefits the high consumers
benefit_high <- CS_high_val / consumer_surplus
high_perc <- benefit_high * 100

# 15.31% of the consumer surplus benefits the low consumers
benefit_low <- CS_low_val / consumer_surplus
low_perc <- benefit_low * 100
```

**Total Consumer Surplus:** `r consumer_surplus` cents

The high income consumers receive `r round(high_perc, 2)`% and the low income consumers receive `r round(low_perc, 2)`% of the total consumer surplus.

## Question 4

```{r}
# optimal electricity tax = 1.97 cents

# Equation of MSC: p = 1.86e-5Q + 1.97
MSC <- lm(msc ~ quantity, data = df_mpc)

# q-tilde = 502,599 kWh
q_tilde <- (D_agg$coefficients[1] - MSC$coefficients[1]) / (MSC$coefficients[2] - D_agg$coefficients[2])

# p-tilde = 11.3 cents
p_tilde <- MSC_fun(q_tilde)

# CS with tax is 4,621,978. Welfare decreases with tax.
cs_w_tax <- CS_agg(p_tilde)

# CS for high income consumers is 3,961,454. Welfare decreased with tax.
cs_high_w_tax <- CS_high(p_tilde)

# CS for low income consumers is 660,524. Welfare decreased with tax.
cs_low_w_tax <- CS_low(p_tilde)

p_tau <- p_tilde - MEC

# PS with tax is 2,347,101. Welfare decreases with tax.
ps_w_tax <- PS(p_tau, MSC_eq(SCC_conversion(51))) #change, eliminated ps function, need PS(p_tau, msc)

# total environmental damage is 988,103
TED <- tax_rev(q_tilde, MEC)

# total environmental damage is 988,103
tot_rev <- tax_rev(q_tilde, MEC)
```

With the social optimal tax:

- **The amount of electricity produced and consumed:** `r q_tilde` kWh
- **The price of electricity:** `r p_tilde`cents
- **Overall welfare for "high" income consumers:** `r cs_high_w_tax` cents
- **Overall welfare for "low" income consumers:** `r cs_low_w_tax` cents
- **Power Suppliers:** `r ps_w_tax`
- **Total Environmental Damage:** `r TED`
- **Total Tax Revenue Generated:** `r tot_rev`

## Question 5

```{r}

```


## Question 6

```{r}

```


# End of homework 3

