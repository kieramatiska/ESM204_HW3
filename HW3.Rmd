---
title: "ESM 204 Homework 3"
author: "Kiera Matiska, Virginia Pan, Devon Rossi"
date: "5/6/2022"
output:
   html_document: 
    code_folding: hide
---

```{r setup, include=FALSE, echo=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = FALSE, warning = FALSE)

library(tidyverse)
#library(rootSolve)
library(janitor)
library(tibble)
library(equatiomatic)
library(kableExtra)
```

```{r}
df <- read_csv("HW3_data.csv") %>% 
  select(-1) %>% 
  clean_names()

```

```{r}
SCC_conversion <- function(SCC_dollars)
{
  #given SCC in $, calc and return SCC in cents/kwH
  SCC <- (100*0.85*SCC_dollars)/2205
  return(SCC)
}
```

```{r}
# creates a function for the supply curve
mpc_curve <- function(q) {
  p <- mpc_slope * q
  p <- ifelse(p < 0, 0, p)
  return(p) }

# define a function to get demand
demand_quant <- function(p, model){
  q <- (p - model$coefficients[[1]])/model$coefficients[[2]]
  q <- ifelse(q<0,0,q)
  return(q) }

# for each p level, return estimated aggregate demand
demand_agg <- function(p){
  q <- demand_quant(p, model_demand_l) + demand_quant(p, model_demand_h)
  return(q)
}

demand_low <- function(p) {
  q <- demand_quant(p, model_demand_l)
  return(q)
}

demand_high <- function(p) {
  q <- demand_quant(p, model_demand_h)
  return(q) }
```


```{r}
  
# function for d_agg equation after kink (to find price)
D_agg_fun <- function(q) {
  p <- (D_agg$coefficients[[2]] * q) + D_agg$coefficients[[1]]
  return(p)
}

```



```{r}
# Linear model Intercept function
lmIntx <- function(fit1, fit2) {
  b1<- fit1$coefficient[1]  #y-int for fit1
  m1<- fit1$coefficient[2]  #slope for fit1
  b2<- fit2$coefficient[1]  #y-int for fit2
  m2<- fit2$coefficient[2]  #slope for fit2
  if(m1==m2 & b1==b2) {print("Lines are identical")
  } else if(m1==m2 & b1 != b2) {print("Lines are parallel")
  } else {
    x <- (b2-b1)/(m1-m2)      #solved general equation for x
    y <- m1*x + b1            #plug in the result
    ordered_pair <- c(x,y)
    return(ordered_pair)
  }
}

true_demand_curve <- function(p)
{
  if(p > model_demand_l$coefficients[1])
  {
    q <-demand_quant(p, model_demand_h)
  }
  if(p <= model_demand_l$coefficients[1])
  {
    q <- demand_quant(p, D_agg)
  }
  return(q)
}
  
```


```{r}
# creates a function for the supply curve
mpc_curve <- function(q) {
  p <- mpc_slope * q
  p <- ifelse(p < 0, 0, p)
  return(p) }
  
supply_quant <- function(p, model) {
  q <- (p - model$coefficients[[1]]) / model$coefficients[[2]]
  q <- ifelse(q < 0, 0, q)
  return(q) }
  
# find MSC function for price
MSC_fun <- function(q) {
  p <- mpc_slope * q + MEC
  return(p)
}


```


```{r}
# I also define functions for calculating the consumer surplus:
CS <- function(p, model){
  q <- demand_quant(p, model)
  cs <- 0.5*(model$coefficients[[1]] - p)*q
  return(cs)
}

CS_agg <- function(p){
  cs <- CS(p,model_demand_l) + CS(p,model_demand_h)
  return(cs)
}

CS_high <- function(p){
  cs <- CS(p, model_demand_h)
  return(cs)
}

CS_low <- function(p){
  cs <- CS(p, model_demand_l)
  return(cs)
}

PS <- function(p, model) {
  q <- supply_quant(p, model)
  ps <- 0.5 * (p - model$coefficient[[1]]) * q
  return(ps)
}

# ps <- function(p) {
#   ps <- PS(p, mpc_model)
#   return(ps)

```




# Questions {.tabset .tabset-fade}

## Question 1

```{r}
# 2205 pounds = 1 ton
# $1 = 100 cents
MEC <- (100 * 0.85 * 51) / 2205
```

The marginal external cost value is `r MEC` cents/kWh.

## Question 2

```{r}
model_demand_l <- lm(price_cents  ~ q_low_kwh, data=df)
model_demand_h <- lm(price_cents ~ q_high_kwh, data=df)

price = seq(0, 30, length.out = 100)
Qagg <- map(price, demand_agg) %>% 
  unlist()
Qlow <- map(price, demand_low) %>% 
  unlist()
Qhigh <- map(price, demand_high) %>% 
  unlist()

df_agg <- tibble(Qagg = Qagg, price = price, mec = MEC)
df_high <- tibble(Q_high = Qhigh, price = price, mec = MEC)
df_low <- tibble(Q_low = Qlow, price = price, mec = MEC)

# Demand Aggregate equation: P = -3.68e-5Q + 29.78
D_agg <- lm(price ~ Qagg, data = df_agg)
p <- 10

# Calculate quantity at free-market equilibrium
d_agg_model <- demand_quant(p, D_agg)
```

```{r}
qh_star <- demand_quant(10, model_demand_h)
ql_star <- demand_quant(10, model_demand_l)
qagg_star <- qh_star + ql_star

high_ratio <- qh_star/qagg_star
low_ratio <- ql_star/qagg_star
```


```{r}
tax_rebate <- function(demand_ratio, SCC, q) {
  tax_reb <- demand_ratio*SCC*q
  return(tax_reb)
}
```

**Aggregate Demand Equation:** P = `r D_agg$coefficients`Q + `r D_agg$coefficients[2]`

**Free-Market Equilibrium:** (`r d_agg_model`, `r p`)

```{r}
# find supply (MPC) curve equation
mpc_slope <- 10 / d_agg_model
# MPC equation: P = 1.86e-5Q

quantity = seq(0, 825000, length.out = 100)
mpc <- map(quantity, mpc_curve) %>% 
  unlist()

df_mpc <- tibble(quantity = quantity, price = mpc, mec = MEC, msc = (mpc_slope * quantity) + mec)

mpc_model <- lm(price ~ quantity, data = df_mpc)
```


```{r}
MSC_eq <- function(MEC){
  MSC <- mpc_model
  MSC$coefficients[1] <- MSC$coefficients[1] + MEC
  return(MSC)
}
```

```{r}
demand_agg_full_eq <- function(SCC)
{
  MSC <- MSC_eq(SCC)
  intersect_high <- lmIntx(MSC,model_demand_h)
  intersect_agg <- lmIntx(MSC, D_agg)
  #check which intersection is correct
  q_option1 <- true_demand_curve(intersect_high[2])
  q_option2 <- true_demand_curve((intersect_agg[2]))
  if(signif(q_option1,3) == signif(intersect_high[1],3))
  {
    eq_p_q <- intersect_high
  }
  else if(signif(q_option2,3) == signif(intersect_agg[1],3))
  {
    eq_p_q <- intersect_agg
  }
  return(eq_p_q)
}
```

```{r}
tax_rev <- function(q, SCC) {
  area <- SCC*q
  return(area)
}
```

```{r}
welfare_h <- function(SCC) {
  eq_p_q <- demand_agg_full_eq(SCC)
  welfare_h <- CS(eq_p_q[2],model_demand_h) +tax_rebate(high_ratio, SCC,eq_p_q[1])
}
```

```{r}
env_damage_fun <- function(q, SCC) {
  env_damage <- q*SCC 
  return(env_damage)
}

welfare_l <- function(SCC)
{
  eq_p_q <- demand_agg_full_eq(SCC)
  welfare_l<-CS(eq_p_q[2],model_demand_l) + tax_rebate(low_ratio, SCC, eq_p_q[1]) - env_damage_fun(eq_p_q[1], SCC)
}

welfare_p <- function(SCC) {
  MSC_func <- MSC_eq(SCC) 
  eq_p_q <- demand_agg_full_eq(SCC)
  p_tau <- eq_p_q[2] - SCC
  producer_wel <- PS(p_tau, MSC_func)
  return(producer_wel)
}
```

```{r}
question_5 <- function(SCC_dollars) {
   SCC <- SCC_conversion(SCC_dollars)
   welfare_high <- welfare_h(SCC)
   welfare_low <- welfare_l(SCC)
   welfare_producer <- welfare_p(SCC)
   welfares <- c(welfare_high, welfare_low, welfare_producer)
   return(welfares)

  
}
 

```


**Supply Curve Equation:** P = `r mpc_slope`Q

```{r}
# consumer surplus = 5,298,722.41 cents
consumer_surplus <- CS_agg(p)

# producer surplus = 2,690,612.46 cents
producer_surplus <- PS(p, mpc_model)

# TEC = 1,057,941.50 cents
TEC <- MEC * d_agg_model
```

**Consumer Surplus:** `r consumer_surplus` cents

**Producer Surplus:** `r producer_surplus` cents

**Total Environmental Cost:** `r TEC` cents

```{r}
ggplot() +
  geom_line(data = df_agg,
            aes(x = Qagg, y = price),
            color = "black") +
  geom_line(data = df_mpc,
            aes(x = quantity, y = price),
            color = "red") +
  geom_hline(yintercept = MEC,
             color = "darkgreen") +
  geom_line(data = df_mpc,
            aes(x = quantity, y = msc),
            color = "blue") +
  geom_line(data = df_high,
            aes(x = Q_high, y = price),
            color = "coral") +
  geom_line(data = df_low,
            aes(x = Q_low, y = price),
            color = "maroon")
```

## Question 3

```{r}
CS_high_val <- CS(p, model_demand_h)
CS_low_val <- CS(p, model_demand_l)

# 84.69% of the consumer surplus benefits the high consumers
benefit_high <- CS_high_val / consumer_surplus
high_perc <- benefit_high * 100

# 15.31% of the consumer surplus benefits the low consumers
benefit_low <- CS_low_val / consumer_surplus
low_perc <- benefit_low * 100
```

**Total Consumer Surplus:** `r consumer_surplus` cents

The high income consumers receive `r round(high_perc, 2)`% and the low income consumers receive `r round(low_perc, 2)`% of the total consumer surplus.

## Question 4

```{r}
# optimal electricity tax = 1.97 cents

# Equation of MSC: p = 1.86e-5Q + 1.97
MSC <- lm(msc ~ quantity, data = df_mpc)

# q-tilde = 502,599 kWh
q_tilde <- (D_agg$coefficients[1] - MSC$coefficients[1]) / (MSC$coefficients[2] - D_agg$coefficients[2])

# p-tilde = 11.3 cents
p_tilde <- MSC_fun(q_tilde)

# CS with tax is 4,621,978. Welfare decreases with tax.
cs_w_tax <- CS_agg(p_tilde)

# CS for high income consumers is 3,961,454. Welfare decreased with tax.
cs_high_w_tax <- CS_high(p_tilde)

# CS for low income consumers is 660,524. Welfare decreased with tax.
cs_low_w_tax <- CS_low(p_tilde) -env_damage_fun(q_tilde,SCC_conversion(51))

p_tau <- p_tilde - MEC

# PS with tax is 2,347,101. Welfare decreases with tax.
ps_w_tax <- PS(p_tau, MSC_eq(SCC_conversion(51))) #change, eliminated ps function, need PS(p_tau, msc)

# total environmental damage is 988,103
TED <- tax_rev(q_tilde, MEC)

# total environmental damage is 988,103
tot_rev <- tax_rev(q_tilde, MEC)
```

With the social optimal tax:

- **The amount of electricity produced and consumed:** `r q_tilde` kWh
- **The price of electricity:** `r p_tilde`cents
- **Overall welfare for "high" income consumers:** `r cs_high_w_tax` cents
- **Overall welfare for "low" income consumers:** `r cs_low_w_tax` cents
- **Power Suppliers:** `r ps_w_tax` cents
- **Total Environmental Damage:** `r TED` cents
- **Total Tax Revenue Generated:** `r tot_rev` cents

## Question 5


```{r}

Q5_51 <- question_5(51)
Q5_75 <- question_5(75)
Q5_100 <- question_5(100)
Q5_125 <- question_5(125)
Q5_150 <- question_5(150)

```
The welfare to high income consumers, welfare to low income consumers, and welfare to electricity producers (all in cents) is presented below for SCC values of 51, 75, 100, 125, and 150 dollars. 

- 51 dollars: `r Q5_51` cents

- 75 dollars: `r Q5_75` cents

- 100 dollars: `r Q5_100` cents

- 125 dollars: `r Q5_125` cents

- 150 dollars: `r Q5_150` cents

## Question 6

```{r}
  #attempt to find solar aggregate demand curve

  #new aggregate demand curve
  #high demand curve has same slope and 1/2 y intercept
  #low demand curve is the same
  #aggregate demand curve is high_demand_solar + low_demand
D_agg_solar <- D_agg
D_agg_solar$coefficients[1]  <- ((model_demand_l$coefficients[1]/model_demand_l$coefficients[2])+((model_demand_h$coefficients[1])/2)/model_demand_h$coefficients[2])
D_agg_solar$coefficients[2] <-
  1/((1/model_demand_l$coefficients[2])+(1/model_demand_h$coefficients[2]))

#find intersect between D_agg_solar and supply curve
eq_p_q_solar <- lmIntx(D_agg_solar,mpc_model)


#intersection of aggregate demand curve and MPC curve is negative, we know this doesn't make sense. Please see approach outlined below. :')

```

Did not have time to code question 6, but this is what we would do: 

6a. 
  Calculate new aggregate demand curve! 
  The high demand curve with solar has same slope as before and 1/2 y intercept as before. 
  The low demand curve is the same. 
  The solar aggregate demand curve = high_demand_solar + low_demand
  Find the intersect between the solar aggregate demand curve and MPC curve. 
  This will tell you the new total electricity consumption and price.
  
6b. 
  The total environmental damage will be the MEC (based on the current $51 SCC) * the new equilibrium quantity of electricity produced. 
  
6c. 
  The value of the electricity tax that makes the total environmental damage the same as the damage when solar panels are available to the high income group  can be determined by trying different tax values and to determine which gives an environmental damage (eq Q * tax) closest to that determined 6b. This tax value will likely be lower than the 51 dollar social cost of carbon. 
  
  Visualizing the increase in the SCC graphically results in greater environmental damage. It is important to note that this value is representative of the "weight" in which environmental costs are assigned - so a higher SCC results in greater environmental damage, while a lower SCC is reflective of "lower" environmental damage. 
  
  
# [Thank you! Peace be with you!](https://www.youtube.com/watch?v=8gyTxsQjdaQ)
*left click, and open link in browser for quick meditation*

